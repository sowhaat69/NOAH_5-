from PyQt5.QAxContainer import *
from PyQt5.QtTest import *
from config.kiwoomType import *
from config.log_class import *
from config.telegramBot import *
from data.Account import *
from data.Screen import *
from data.Stock import *
from data.Eventloop import *
from data.Signal import *
import pandas as pd
import pandas_ta as ta
from datetime import date, datetime


class Kiwoom(QAxWidget):

    def __init__(self):
        super().__init__()
        self.log = Logging().logger
        self.log.debug("Kiwoom() class Start")
        ####시간관리############
        self.noah_time()
        self.maxim = None
        ####클래스###########
        self.realType = RealType()
        self.account = Account()
        self.screen = Screen()
        self.stock = Stock()
        self.loop = Eventloop()
        self.bot = telegramBot()
        self.signal = Signal()
        ####로그인처리###############
        self.get_ocx_instance()
        self.event_slots()
        self.signal_login_commConnect()
        ####반복함수###############
        if 900 <= self.d_time <= 901:
            for i in range(6):
                self.noah()
                QTest.qWait(10000)
        else:
            for i in range(3):
                self.noah()
                QTest.qWait(20000)

    #####노아운영함수################################
    def noah_time(self):
        self.date = date.today().strftime('%Y%m%d')
        self.mini_date = date.today().strftime('%m%d')
        self.month = datetime.now().month
        self.weekday = datetime.today().weekday()
        self.hour = datetime.now().hour
        self.minute = datetime.now().minute
        self.d_time = int(self.hour) * 100 + int(self.minute)
        self.minute_before = 60 - int(self.minute)

        if (self.month == 3 or 6 or 9 or 12) and (self.weekday == 3) and (7 < int(self.mini_date[-2:]) <= 14):
            self.log.debug('선물만기일입니다. 거래에 유의하세요')
            print()
        else:
            pass

    def noah(self):
        self.get_account_info()
        self.get_stock_info()
        self.get_future_detail_info()
        self.future_1_minute_chart()
        self.future_day_chart()
        self.get_future_can_buy()
        self.future_30_minute_chart()
        self.future_120_minute_chart()
        self.signal_logger()
        self.get_order_detail_info()
        self.find_secure_return()

        self.run()

    def run(self):
        if 850 <= self.d_time < 900:
            self.log.debug(f'장 개시 {self.minute_before}분 전입니다.')
            self.bot.send(f'장 개시 {self.minute_before}분 전입니다.')
            quit()
        elif 900 <= self.d_time < 1533:
            self.stop_trade()
            self.close_position()
            self.stop_loss()
            self.trade_future()

            self.bot.send(f'오늘 실현수익: {self.today_return}')
            self.bot.send(f'현재 평가수익: {self.return_guess}')
            self.log.debug(f'오늘 실현수익: {self.today_return}')
            self.log.debug(f'현재 평가수익: {self.return_guess}')
            print()

        elif 1533 <= self.d_time < 1535:
            if self.amount > 0 and self.memegubun == '매도':
                self.buy_future()
                self.log.debug('오늘 거래를 청산합니다!')
                self.bot.send('오늘 거래를 청산합니다!')
                self.bot.send(f'계좌수익률: {self.account.total_return}')
                self.bot.send(f'오늘 실현수익: {self.today_return}')
            elif self.amount > 0 and self.memegubun == '매수':
                self.sell_future()
                self.log.debug('오늘 거래를 청산합니다!')
                self.bot.send('오늘 거래를 청산합니다!')
                self.bot.send(f'계좌수익률: {self.account.total_return}')
                self.bot.send(f'오늘 실현수익: {self.today_return}')
            elif self.amount == 0:
                self.log.debug('오늘 거래를 마감합니다!')
                self.bot.send('오늘 거래를 마감합니다!')
                self.bot.send(f'계좌수익률: {self.account.total_return}')
                self.bot.send(f'오늘 실현수익: {self.today_return}')

            else:
                pass

        elif 1535 <= self.d_time < 1537:
            self.log.debug('거래시간이 아닙니다.')
            self.bot.send('거래시간이 아닙니다.')
            print()
            quit()

        else:
            self.log.debug('거래시간이 아닙니다.')

    ###매매 전략 함수##########################

    def stop_trade(self):

        if self.today_return < 0 \
            and len(self.order_details) / self.account.contract_num >= 4 \
            and self.order_times[-4 * self.account.contract_num] \
            == self.order_times[-3 * self.account.contract_num] \
            == self.order_times[-2 * self.account.contract_num] \
            == self.order_times[-1 * self.account.contract_num] == self.now_30bong:
            
            self.log.debug('[매매금지조건검색]손실거래 2회로 잠시 휴식 후 다음 30분봉부터 거래를 재개합니다.')
            self.bot.send('[매매금지조건검색]손실거래 2회로 잠시 휴식 후 다음 30분봉부터 거래를 재개합니다.')
            quit()
        else:
            pass

        if 900 <= self.d_time < 1100:
            if (self.mnt120_ma20_2 > self.close2_120 and self.mnt120_ma20_1 < self.close1_120) \
                    and (self.mnt120_ma20_1 + 1 < self.open1_120):
                self.log.debug('[매매금지조건검색]포지션 바뀔 때 갭 1포인트 밖이어서 매매하지 않습니다.')
                quit()

            elif (self.mnt120_ma20_2 < self.close2_120 and self.mnt120_ma20_1 > self.close1_120) \
                    and (self.mnt120_ma20_1 - 1 > self.open1_120):
                self.log.debug('[매매금지조건검색]포지션 바뀔 때 갭 1포인트 밖이어서 매매하지 않습니다.')
                quit()
            else:
                pass
        else:
            self.log.debug('[매매금지조건검색]해당되는 매매금지조건이 없습니다.')
            print()

    def stop_loss(self):
        
        if self.minim < -1:
            if self.memegubun == '매수':
                self.sell_future()
                self.log.debug('[스탑로스조건검색] 1포인트 손절합니다.')
                print()
                self.bot.send('[스탑로스조건검색] 1포인트 손절합니다.')
            elif self.memegubun == '매도':
                self.buy_future()
                self.log.debug('[스탑로스조건검색] 1포인트 손절합니다.')
                print()
                self.bot.send('[스탑로스조건검색] 1포인트 손절합니다.')
            else:
                pass
        else:
            self.log.debug('[스탑로스조건검색]손절조건이 없습니다.')
            print()

    def trade_future(self):
        
        if self.weekday != 5 and self.weekday != 6 and self.d_time < 1500:
            if self.signal.market_state == 'bull' \
                    and self.signal.buy_sig_30 == 'O' \
                    and self.signal.buy_sig_120 == 'O' \
                    and self.amount == 0 \
                    and self.close1_30 < self.close5_30 + 1:
                self.buy_future()
                self.log.debug('[매매가능조건검색]신규 매수합니다.')
                print()
                self.bot.send('[매매가능조건검색]신규 매수합니다.')
            elif self.signal.market_state == 'bear' \
                    and self.signal.sell_sig_30 == 'O' \
                    and self.signal.sell_sig_120 == 'O' \
                    and self.amount == 0 \
                    and self.close1_30 > self.close5_30 - 1:
                self.sell_future()
                self.log.debug('[매매가능조건검색]신규 매도합니다.')
                print()
                self.bot.send('[매매가능조건검색]신규 매도합니다.')
            else:
                self.log.debug('[매매가능조건검색]맞는 조건이 없어 매매를 하지 않습니다.')
                print()
        else:
            self.log.debug('[매매가능조건검색]매매 가능 시간이 아닙니다.')
            print()

    def close_position(self):
        
        if self.return_guess <= self.secure_return - 0.2 * self.account.point:
            if self.memegubun == '매수':
                self.sell_future()
            elif self.memegubun == '매도':
                self.buy_future()
            else:
                pass
        else:
            pass
        try:
            if (self.signal.close_buy_30 == 'O' or self.signal.close_buy_120 == 'O') and self.amount > 0 and self.memegubun == '매수':
                self.sell_future()
                self.log.debug('[매매청산조건검색] 5원소 이탈로 즉시 청산합니다.')
                print()
                self.bot.send('[매매청산조건검색] 5원소 이탈로 즉시 청산합니다.')
                self.bot.send(f'당일손익: {self.today_return}')
            elif (self.signal.close_sell_30 == 'O' or self.signal.close_sell_120 == 'O') and self.amount > 0 and self.memegubun == '매도':
                self.buy_future()
                self.log.debug('[매매청산조건검색] 5원소 이탈로 즉시 청산합니다.')
                print()
                self.bot.send('[매매청산조건검색] 5원소 이탈로 즉시 청산합니다.')
                self.bot.send(f'당일손익: {self.today_return}')

            else:
                self.log.debug('[매매청산조건검색] 매매청산조건이 없습니다.')
                print()

        except AttributeError:
            self.log.debug('[매매청산조건검색] 청산할 매매가 없습니다.')
            print()

        except IndexError:
            self.log.debug('[매매청산조건검색] 청산할 매매가 없습니다.')
            print()

    def find_secure_return(self):

        if len(self.order_prices) == 0 and self.amount == 0:
            self.maxim = 0
            self.minim = 0
        elif len(self.order_prices) != 0 and self.amount == 0:
            self.maxim = 0
            self.minim = 0
        elif len(self.order_prices) != 0 and self.amount != 0:
            if self.memegubun == '매수':
                self.maxim = (self.highafter30 - self.order_prices[-1])
                self.minim = (self.lowafter30 - self.order_prices[-1])
            elif self.memegubun == '매도':
                self.maxim = (self.order_prices[-1] - self.lowafter30)
                self.minim = (self.highafter30 - self.order_prices[-1])
            else:
                pass
        if self.maxim - int(self.maxim) > 0.5:
            self.secure_return = (int(self.maxim) + 0.5) * self.account.point
        else:
            self.secure_return = int(self.maxim) * self.account.point

        self.log.debug(f'확보해야할 평가수익: {self.secure_return}')
    ####################################################

    ###이벤트요청함수######################################

    def get_ocx_instance(self):
        self.setControl("KHOPENAPI.KHOpenAPICtrl.1")

    def signal_login_commConnect(self):
        self.dynamicCall("CommConnect()")
        self.loop.login.exec_()

    def get_order_detail_info(self):
        self.dynamicCall("SetInputValue(QString, QString)", "계좌번호", self.account.account_num)
        self.dynamicCall("SetInputValue(QString, QString)", "비밀번호", self.account.password)
        self.dynamicCall("SetInputValue(QString, QString)", "조회일", self.date)
        self.dynamicCall("SetInputValue(QString, QString)", "종목구분", '0')
        self.dynamicCall("SetInputValue(QString, QString)", "조회구분", '0')
        self.dynamicCall("SetInputValue(QString, QString)", "정렬구분", '1')
        self.dynamicCall("SetInputValue(QString, QString)", '비밀번호입력매체구분', '00')
        self.dynamicCall("SetInputValue(QString, QString)", '정규시간외구분', '1')

        self.dynamicCall("CommRqData(QString, QString, int, QString)", "선옵주문체결내역상세요청", "opw20004", "0",
                         self.screen.order_detail)
        self.loop.order_detail.exec_()

    def get_account_info(self):
        account_list = self.dynamicCall("GetLoginInfo(QString)", "ACCNO")
        # print(f'계좌리스트:{account_list}')
        self.account.account_num = account_list.split(';')[self.account.account_list_num]
        self.log.debug("거래용 계좌번호 %s" % self.account.account_num)
        print()
        self.dynamicCall("SetInputValue(QString, QString)", "계좌번호", self.account.account_num)
        self.dynamicCall("SetInputValue(QString, QString)", "비밀번호입력매체구분", "00")
        self.dynamicCall("CommRqData(QString, QString, int, QString)", "선옵증거금상세내역요청", "opw20012", "0",
                         self.screen.my_info)

    def get_stock_info(self, sPrevNext="0"):
        self.dynamicCall("SetInputValue(QString, QString)", "계좌번호", self.account.account_num)
        self.dynamicCall("CommRqData(QString, QString, int, QString)", "선옵잔고요청", "OPT50027", sPrevNext,
                         self.screen.my_info)

    def get_future_detail_info(self):
        self.dynamicCall("SetInputValue(QString, QString)", "계좌번호", self.account.account_num)
        self.dynamicCall("SetInputValue(QString, QString)", "비밀번호", self.account.password)
        self.dynamicCall("SetInputValue(QString, QString)", "조회일자", self.date)
        self.dynamicCall("SetInputValue(QString, QString)", '비밀번호입력매체구분', '00')

        self.dynamicCall("CommRqData(QString, QString, int, QString)", "선옵잔고상세현황요청", "opw20006", '0',
                         self.screen.my_info)
        self.loop.future_detail_info.exec_()

    def get_future_can_buy(self):
        self.dynamicCall("SetInputValue(QString, QString)", "계좌번호", self.account.account_num)
        self.dynamicCall("SetInputValue(QString, QString)", "비밀번호", self.account.password)
        self.dynamicCall("SetInputValue(QString, QString)", "종목코드", '101T3000')
        self.dynamicCall("SetInputValue(QString, QString)", "매도수구분", '1')
        self.dynamicCall("SetInputValue(QString, QString)", "주문유형", '3')
        self.dynamicCall("SetInputValue(QString, QString)", "주문가격", str(self.close * 1000))
        self.dynamicCall("SetInputValue(QString, QString)", "비밀번호입력매체구분", '')
        self.dynamicCall("CommRqData(QString, QString, int, QString)", '선옵계좌별주문가능수량요청', "opw20009", "0",
                         self.screen.can_buy)
        self.loop.can_buy.exec_()

    ####################################

    ###차트요청함수######################
    def future_1_minute_chart(self):
        self.dynamicCall("SetInputValue(QString, QString", "종목코드", '101T3000')
        self.dynamicCall("SetInputValue(QString, QString", "시간단위", '1')
        self.dynamicCall("CommRqData(QString, QString, int, QString)", "선물옵션1분차트요청", "OPT50029", 0,
                         self.screen.future_minute_chart)
        self.loop.future_1minute_chart.exec_()

    def future_30_minute_chart(self):
        self.dynamicCall("SetInputValue(QString, QString", "종목코드", '101T3000')
        self.dynamicCall("SetInputValue(QString, QString", "시간단위", '30')
        self.dynamicCall("CommRqData(QString, QString, int, QString)", "선물옵션30분차트요청", "OPT50029", 0,
                         self.screen.future_minute_chart)
        self.loop.future_30minute_chart.exec_()

    def future_120_minute_chart(self):
        self.dynamicCall("SetInputValue(QString, QString", "종목코드", '101T3000')
        self.dynamicCall("SetInputValue(QString, QString", "시간단위", '120')
        self.dynamicCall("CommRqData(QString, QString, int, QString)", "선물옵션120분차트요청", "OPT50029", 0,
                         self.screen.future_minute_chart)
        self.loop.future_120minute_chart.exec_()

    def future_day_chart(self):
        self.dynamicCall("SetInputValue(QString, QString", "종목코드", '101T3000')
        self.dynamicCall("SetInputValue(QString, QString", "기준일자", self.date)
        self.dynamicCall("CommRqData(QString, QString, int, QString)", "선물옵션일차트요청", "OPT50030", 0,
                         self.screen.day_chart)
        self.loop.day_chart.exec_()

    #######################################

    ###이벤트slot함수################################
    def event_slots(self):
        self.OnEventConnect.connect(self.login_slot)
        self.OnReceiveTrData.connect(self.trdata_slot)
        # self.OnReceiveMsg.connect(self.msg_slot)

    def login_slot(self, err_code):
        if err_code == 0:
            self.log.debug("키움 Open API 접속 완료")
        self.loop.login.exit()

    # def msg_slot(self, sCrNo, sRQName, sTrCode, msg):
    #     self.log.debug("[Screen : %s] %s %s %s" % (sCrNo, sRQName, sTrCode, msg))

    def trdata_slot(self, sCrNo, sRQName, sTrCode, sRecordName):
        # print("TRDATA : %s" % sRQName)
        if sRQName == "선옵증거금상세내역요청":
            self.tr_get_account_info(sRQName, sTrCode)
        elif sRQName == "선옵잔고요청":
            self.tr_get_stock_info(sRQName, sTrCode)
        elif sRQName == "선옵잔고상세현황요청":
            self.tr_get_future_detail_info(sRQName, sTrCode)
        elif sRQName == '선물옵션1분차트요청':
            self.tr_get_future_1_minute_chart(sTrCode, sRQName)
        elif sRQName == '선물옵션30분차트요청':
            self.tr_get_future_30_minute_chart(sTrCode, sRQName)
        elif sRQName == '선물옵션120분차트요청':
            self.tr_get_future_120_minute_chart(sTrCode, sRQName)
        elif sRQName == '선물옵션일차트요청':
            self.tr_get_future_day_chart(sTrCode, sRQName)
        elif sRQName == "선옵주문체결내역상세요청":
            self.tr_get_order_detail_info(sTrCode, sRQName)
        elif sRQName == '선옵계좌별주문가능수량요청':
            self.tr_get_future_can_buy(sTrCode, sRQName)
        elif sRQName == '매수':
            pass
        elif sRQName == '매도':
            pass

    ##################################

    ###TR함수##########################
    def tr_get_order_detail_info(self, sTrCode, sRQName):

        rows = self.dynamicCall('GetRepeatCnt(QString, QString)', sTrCode, sRQName)
        if rows == 0:
            self.order_details = []
            self.order_prices = []
            self.order_times = []
        else:
            try:
                self.order_details = []
                self.order_prices = []
                self.order_times = []
                self.order_1minbongs = []
                for i in range(0, rows, self.account.contract_num):
                    order_detail = self.dynamicCall("GetCommData(QString, QString, int, QString)", sTrCode, sRQName, i,
                                                    "매매구분").strip()
                    order_price = int(
                        self.dynamicCall("GetCommData(QString, QString, int, QString)", sTrCode, sRQName, i,
                                         "체결가격")) / 1000
                    order_time = self.dynamicCall("GetCommData(QString, QString, int, QString)", sTrCode, sRQName, i,
                                                  "약정시간")[
                                 :5].replace(':', '')
                    self.order_details.append(order_detail)
                    self.order_prices.append(order_price)
                    self.order_1minbongs.append(self.mini_date + str(order_time).zfill(4))
                    a = int(order_time)
                    b = str(int(a / 100)).zfill(2)
                    c = a % 100
                    if c < 30:
                        c = '00'
                    else:
                        c = '30'
                    self.order_times.append(self.mini_date + b + c)
            except ValueError:
                pass
        self.loop.order_detail.exit()

        try:
            self.highafter30 = max(
                self.future_df_1[
                self.future_df_1[self.future_df_1['Time'] == self.order_1minbongs[-1]].index[0] - 1:].High.values)
            self.lowafter30 = min(
                self.future_df_1[
                self.future_df_1[self.future_df_1['Time'] == self.order_1minbongs[-1]].index[0] - 1:].Low.values)

            self.log.debug(f'최근 체결가: {self.order_prices[-1]}')
            self.log.debug(f'최근 체결봉: {self.order_times[-1]}')
            self.log.debug(f'최근 체결구분: {self.order_details[-1]}')
            self.log.debug(f"거래후 최고가: {self.highafter30}")
            self.log.debug(f"거래후 최저가: {self.lowafter30}")
            print()

        except IndexError:
            if 900 <= self.d_time < 1530:
                self.log.debug('아직 오늘 장의 체결 정보가 없습니다.')
                print()
        except AttributeError:
            if 900 <= self.d_time < 1530:
                self.log.debug('아직 오늘 장의 체결 정보가 없습니다.')
                print()
        else:
            pass

    def tr_get_future_can_buy(self, sTrCode, sRQName):
        self.total_can_amount = int(
            self.dynamicCall("GetCommData(QString, QString, int, QString)", sTrCode, sRQName, 0, "총가능수량"))
        self.new_can_amount = int(
            self.dynamicCall("GetCommData(QString, QString, int, QString)", sTrCode, sRQName, 0, "신규가능수량"))
        self.can_cast = int(
            self.dynamicCall("GetCommData(QString, QString, int, QString)", sTrCode, sRQName, 0, "청산가능수량"))
        self.log.debug(f'총가능수량:{self.total_can_amount}')
        self.log.debug(f'신규가능수량:{self.new_can_amount}')
        self.log.debug(f'청산가능수량:{self.can_cast}')
        print()
        self.loop.can_buy.exit()

    def tr_get_future_1_minute_chart(self, sTrCode, sRQName):
        times = []
        opens = []
        highs = []
        lows = []
        closes = []
        volumes = []
        rows = self.dynamicCall('GetRepeatCnt(QString, QString)', sTrCode, sRQName)

        for i in range(rows, -1, -1):
            time = self.dynamicCall("GetCommData(QString, QString, int, QString)", sTrCode, sRQName, i,
                                    "체결시간").strip()[
                   4:12]
            open = self.dynamicCall("GetCommData(QString, QString, int, QString)", sTrCode, sRQName, i,
                                    "시가").strip().lstrip('+').lstrip('-')
            high = self.dynamicCall("GetCommData(QString, QString, int, QString)", sTrCode, sRQName, i,
                                    "고가").strip().lstrip('+').lstrip('-')
            low = self.dynamicCall("GetCommData(QString, QString, int, QString)", sTrCode, sRQName, i,
                                   "저가").strip().lstrip('+').lstrip('-')
            close = self.dynamicCall("GetCommData(QString, QString, int, QString)", sTrCode, sRQName, i,
                                     "현재가").strip().lstrip('+').lstrip('-')
            volume = self.dynamicCall("GetCommData(QString, QString, int, QString)", sTrCode, sRQName, i,
                                      "거래량").strip()
            times.append(time)
            opens.append(open)
            highs.append(high)
            lows.append(low)
            closes.append(close)
            volumes.append(volume)

        future_ohlcv_1 = {'Time': times, 'Open': opens, 'High': highs, 'Low': lows, 'Close': closes,
                          'Volume': volumes}
        self.future_df_1 = pd.DataFrame(future_ohlcv_1)
        self.future_df_1[['Open', 'High', 'Low', 'Close', 'Volume']] = self.future_df_1[
            ['Open', 'High', 'Low', 'Close', 'Volume']].apply(pd.to_numeric)
        self.future_df_1 = self.future_df_1.dropna()

        self.loop.future_1minute_chart.exit()

    def tr_get_future_30_minute_chart(self, sTrCode, sRQName):
        times = []
        opens = []
        highs = []
        lows = []
        closes = []
        volumes = []
        rows = self.dynamicCall('GetRepeatCnt(QString, QString)', sTrCode, sRQName)

        for i in range(rows, -1, -1):
            time = self.dynamicCall("GetCommData(QString, QString, int, QString)", sTrCode, sRQName, i,
                                    "체결시간").strip()[
                   4:12]
            open = self.dynamicCall("GetCommData(QString, QString, int, QString)", sTrCode, sRQName, i,
                                    "시가").strip().lstrip('+').lstrip('-')
            high = self.dynamicCall("GetCommData(QString, QString, int, QString)", sTrCode, sRQName, i,
                                    "고가").strip().lstrip('+').lstrip('-')
            low = self.dynamicCall("GetCommData(QString, QString, int, QString)", sTrCode, sRQName, i,
                                   "저가").strip().lstrip('+').lstrip('-')
            close = self.dynamicCall("GetCommData(QString, QString, int, QString)", sTrCode, sRQName, i,
                                     "현재가").strip().lstrip('+').lstrip('-')
            volume = self.dynamicCall("GetCommData(QString, QString, int, QString)", sTrCode, sRQName, i,
                                      "거래량").strip()
            times.append(time)
            opens.append(open)
            highs.append(high)
            lows.append(low)
            closes.append(close)
            volumes.append(volume)

        future_ohlcv_30 = {'Time': times, 'Open': opens, 'High': highs, 'Low': lows, 'Close': closes,
                           'Volume': volumes}
        self.future_df_30 = pd.DataFrame(future_ohlcv_30)

        self.future_df_30[['Open', 'High', 'Low', 'Close', 'Volume']] = self.future_df_30[
            ['Open', 'High', 'Low', 'Close', 'Volume']].apply(pd.to_numeric)
        self.future_df_30 = self.future_df_30.dropna()
        self.future_df_30['ma20'] = ta.sma(self.future_df_30.Close, length=20)
        self.mnt30_ma20_1 = self.future_df_30['ma20'].values[-1]
        self.now_price = self.future_df_30.Close.values[-1]
        self.now_30bong = self.future_df_30.Time.values[-1][4:]

        self.close5_30 = self.future_df_30.Close.values[-5]
        self.close1_30 = self.future_df_30.Close.values[-1]
        self.high1_30 = self.future_df_30.High.values[-1]
        self.low1_30 = self.future_df_30.Low.values[-1]
        self.close6_30 = self.future_df_30.Close.values[-6]
        self.close2_30 = self.future_df_30.Close.values[-2]

        if self.close5_30 < self.close1_30:
            self.signal.buy_sig_30 = 'O'
        elif self.close5_30 > self.close1_30:
            self.signal.sell_sig_30 = 'O'
        else:
            pass

        if self.close5_30 < self.close1_30 and self.close6_30 < self.close2_30:
            self.signal.close_sell_30 = 'O'
        elif self.close5_30 > self.close1_30 and self.close6_30 > self.close2_30:
            self.signal.close_buy_30 = 'O'
        else:
            pass

        self.loop.future_30minute_chart.exit()

    def tr_get_future_120_minute_chart(self, sTrCode, sRQName):
        times = []
        opens = []
        highs = []
        lows = []
        closes = []
        volumes = []
        rows = self.dynamicCall('GetRepeatCnt(QString, QString)', sTrCode, sRQName)

        for i in range(rows, -1, -1):
            time = self.dynamicCall("GetCommData(QString, QString, int, QString)", sTrCode, sRQName, i,
                                    "체결시간").strip()[
                   4:12]
            open = self.dynamicCall("GetCommData(QString, QString, int, QString)", sTrCode, sRQName, i,
                                    "시가").strip().lstrip('+').lstrip('-')
            high = self.dynamicCall("GetCommData(QString, QString, int, QString)", sTrCode, sRQName, i,
                                    "고가").strip().lstrip('+').lstrip('-')
            low = self.dynamicCall("GetCommData(QString, QString, int, QString)", sTrCode, sRQName, i,
                                   "저가").strip().lstrip('+').lstrip('-')
            close = self.dynamicCall("GetCommData(QString, QString, int, QString)", sTrCode, sRQName, i,
                                     "현재가").strip().lstrip('+').lstrip('-')
            volume = self.dynamicCall("GetCommData(QString, QString, int, QString)", sTrCode, sRQName, i,
                                      "거래량").strip()

            times.append(time)
            opens.append(open)
            highs.append(high)
            lows.append(low)
            closes.append(close)
            volumes.append(volume)

        future_ohlcv_120 = {'Open': opens, 'High': highs, 'Low': lows, 'Close': closes, 'Volume': volumes}
        future_df_120 = pd.DataFrame(future_ohlcv_120)

        future_df_120[['Open', 'High', 'Low', 'Close', 'Volume']] = future_df_120[
            ['Open', 'High', 'Low', 'Close', 'Volume']].apply(pd.to_numeric)
        future_df_120 = future_df_120.dropna()
        future_df_120['m20'] = ta.sma(future_df_120.Close, length=20)

        self.mnt120_ma20_1 = future_df_120['m20'].values[-1]
        self.mnt120_ma20_2 = future_df_120['m20'].values[-2]
        self.mnt120_ma20_3 = future_df_120['m20'].values[-3]
        self.mnt120_ma20_4 = future_df_120['m20'].values[-4]
        self.mnt120_ma20_5 = future_df_120['m20'].values[-5]

        self.close1_120 = future_df_120.Close.values[-1]
        self.close2_120 = future_df_120.Close.values[-2]
        self.close3_120 = future_df_120.Close.values[-3]
        self.close5_120 = future_df_120.Close.values[-5]
        self.close6_120 = future_df_120.Close.values[-6]
        self.close7_120 = future_df_120.Close.values[-7]

        self.open1_120 = future_df_120.Open.values[-1]

        self.high1_120 = future_df_120.High.values[-1]
        self.high2_120 = future_df_120.High.values[-2]
        self.high3_120 = future_df_120.High.values[-3]
        self.high4_120 = future_df_120.High.values[-4]
        self.high5_120 = future_df_120.High.values[-5]

        self.low1_120 = future_df_120.Low.values[-1]
        self.low2_120 = future_df_120.Low.values[-2]
        self.low3_120 = future_df_120.Low.values[-3]
        self.low4_120 = future_df_120.Low.values[-4]
        self.low5_120 = future_df_120.Low.values[-5]

        if self.close1_120 >= self.mnt120_ma20_1:
            self.signal.market_state = 'bull'
        elif self.close1_120 < self.mnt120_ma20_1:
            self.signal.market_state = 'bear'

        if self.close5_120 < self.close1_120:
            self.signal.buy_sig_120 = 'O'
        elif self.close5_120 > self.close1_120:
            self.signal.sell_sig_120 = 'O'
        else:
            pass

        if self.close6_120 > self.close2_120 and self.close5_120 > self.close1_120:
            self.signal.close_buy_120 = 'O'
        elif self.close6_120 < self.close2_120 and self.close5_120 < self.close1_120:
            self.signal.close_sell_120 = 'O'
        else:
            pass
        self.loop.future_120minute_chart.exit()

    def signal_logger(self):
        print('----------------------------------------------------------------------------------------------------')
        self.log.debug(f'30분 매수신호: {self.signal.buy_sig_30}')
        self.log.debug(f'120분 매수신호: {self.signal.buy_sig_120}')
        print('----------------------------------------------------------------------------------------------------')
        self.log.debug(f'30분 매도신호: {self.signal.sell_sig_30}')
        self.log.debug(f'120분 매도신호: {self.signal.sell_sig_120}')
        print('----------------------------------------------------------------------------------------------------')
        self.log.debug(f'30분 매수청산신호: {self.signal.close_buy_30}')
        self.log.debug(f'120분 매수청산신호: {self.signal.close_buy_120}')
        print('----------------------------------------------------------------------------------------------------')
        self.log.debug(f'30분 매도청산신호: {self.signal.close_sell_30}')
        self.log.debug(f'120분 매도청산신호: {self.signal.close_sell_120}')
        print('----------------------------------------------------------------------------------------------------')
        print()

    def tr_get_future_day_chart(self, sTrCode, sRQName):
        dates = []
        opens = []
        highs = []
        lows = []
        closes = []
        rows = self.dynamicCall('GetRepeatCnt(QString, QString)', sTrCode, sRQName)

        for i in range(rows, -1, -1):
            date = self.dynamicCall("GetCommData(QString, QString, int, QString)", sTrCode, sRQName, i,
                                    "체결시간").strip()[
                   4:12]
            open = self.dynamicCall("GetCommData(QString, QString, int, QString)", sTrCode, sRQName, i,
                                    "시가").strip().lstrip('+').lstrip('-')
            high = self.dynamicCall("GetCommData(QString, QString, int, QString)", sTrCode, sRQName, i,
                                    "고가").strip().lstrip('+').lstrip('-')
            low = self.dynamicCall("GetCommData(QString, QString, int, QString)", sTrCode, sRQName, i,
                                   "저가").strip().lstrip('+').lstrip('-')
            close = self.dynamicCall("GetCommData(QString, QString, int, QString)", sTrCode, sRQName, i,
                                     "현재가").strip().lstrip('+').lstrip('-')

            dates.append(date)
            opens.append(open)
            highs.append(high)
            lows.append(low)
            closes.append(close)

        future_ohlcv_day = {'Open': opens, 'High': highs, 'Low': lows, 'Close': closes}
        future_df_day = pd.DataFrame(future_ohlcv_day)

        future_df_day[['Open', 'High', 'Low', 'Close']] = future_df_day[
            ['Open', 'High', 'Low', 'Close']].apply(pd.to_numeric)
        future_df_day = future_df_day.dropna()

        self.open = future_df_day.Open.values[-1]
        self.high = future_df_day.High.values[-1]
        self.high2 = future_df_day.High.values[-2]
        self.low = future_df_day.Low.values[-1]
        self.close = future_df_day.Close.values[-1]
        self.junil_close = future_df_day.Close.values[-2]
        self.open_gap = round((self.open - self.junil_close), 2)

        self.log.debug(f'전일종가: {self.junil_close}')
        self.log.debug(f'금일시가: {self.open}')
        self.log.debug(f'시가갭: {self.open_gap}')
        self.log.debug(f'현재가: {self.close}')
        print()

        self.loop.day_chart.exit()

    def tr_get_account_info(self, sRQName, sTrCode):
        self.account.total_money = int(
            self.dynamicCall("GetCommData(QString, QString, int, QString)", sTrCode, sRQName, 0,
                             "예탁평가총액").strip())
        self.account.can_buy_money = int(
            self.dynamicCall("GetCommData(QString, QString, int, QString)", sTrCode, sRQName, 0,
                             "주문가능총액").strip())
        self.account.total_return = round(
            ((self.account.total_money - self.account.original_deposit) / self.account.original_deposit) * 100,
            2)
        self.log.debug(f'예탁평가총액:  {self.account.total_money}')
        self.log.debug(f'출금가능금액:  {self.account.can_buy_money}')
        self.log.debug(f'원금대비 계좌수익율(%): {self.account.total_return}')
        print()

        self.loop.account_info.exit()

    def tr_get_future_detail_info(self, sRQName, sTrCode):
        rows = self.dynamicCall('GetRepeatCnt(Qstring, Qstring)', sTrCode, sRQName)

        if rows == 0:
            self.amount = 0
            self.return_guess = 0
            self.memegubun = '없음'

        else:
            for i in range(rows):
                self.return_guess = self.dynamicCall("GetCommData(QString, QString, int, QString)", sTrCode,
                                                     sRQName, i, "평가손익")
                if self.return_guess == '':
                    self.return_guess = 0
                self.memegubun = self.dynamicCall("GetCommData(QString, QString, int, QString)", sTrCode,
                                                  sRQName, i, "매매구분").strip()
                if self.memegubun == '':
                    self.memegubun = '없음'

                self.amount = self.dynamicCall("GetCommData(QString, QString, int, QString)", sTrCode, sRQName,
                                               i,
                                               "잔고수량")
                if self.amount == '':
                    self.amount = 0

        self.amount = int(self.amount)
        self.return_guess = int(self.return_guess)

        self.log.debug(f'매매구분: {self.memegubun}')
        self.log.debug(f'평가손익: {self.return_guess}')
        self.log.debug(f'잔고수량: {self.amount}')
        print()

        self.loop.future_detail_info.exit()

    def tr_get_stock_info(self, sRQName, sTrCode):
        rows = self.dynamicCall('GetRepeatCnt(Qstring, Qstring)', sTrCode, sRQName)

        if rows == 0:
            self.trade_price = 0
            self.stock.name = '없음'
            self.stock.code = '없음'
            self.today_return = 0
        else:
            for i in range(rows):
                self.stock.code = str(
                    self.dynamicCall("GetCommData(QString, QString, int, QString)", sTrCode, sRQName, i,
                                     "종목코드").strip())
                self.stock.name = self.dynamicCall("GetCommData(QString, QString, int, QString)", sTrCode,
                                                   sRQName, i,
                                                   "종목명").strip()
                self.trade_price = float(
                    self.dynamicCall("GetCommData(QString, QString, int, QString)", sTrCode, sRQName, i,
                                     "매입단가").strip())
                self.today_return = int(
                    self.dynamicCall("GetCommData(QString, QString, int, QString)", sTrCode, sRQName, i,
                                     "당일총매도손익"))
        self.today_point_get = round(self.today_return / self.account.point, 2)

        self.log.debug(f'보유종목명:{self.stock.name}')
        self.log.debug(f'보유종목코드:{self.stock.code}')
        self.log.debug(f'당일손익/원:{self.today_return}원')
        self.log.debug(f'당일손익/포인트:{self.today_point_get}P')
        print()

        self.loop.account_info.exit()

    ###매매주문함수##################
    def sell_future(self):
        status = self.dynamicCall(
            'SendOrderFO(QString,QString,QString,QString,int,QString,QString,int,int,QString,)',
            ['매도', self.screen.buy_sell, self.account.account_num, '101T3000', 1, '1', '3', self.account.contract_num,
             0, ''])

    def buy_future(self):
        status = self.dynamicCall(
            'SendOrderFO(QString,QString,QString,QString,int,QString,QString,int,int,QString,)',
            ['매수', self.screen.buy_sell, self.account.account_num, '101T3000', 1, '2', '3', self.account.contract_num,
             0, ''])
    ###############################se
